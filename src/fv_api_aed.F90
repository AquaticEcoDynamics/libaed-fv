!###############################################################################
!#                                                                             #
!# fv_api_aed.F90                                                              #
!#                                                                             #
!# Interface for FV (Finite Volume) Hydrodynamic Model to AED modules (libaed) #
!#   Designed for TUFLOW-FV, released by BMT Pty Ltd:                          #
!#   http://www.tuflow.com/Tuflow%20FV.aspx                                    #
!#                                                                             #
!# This is the main interface module that manages the connection with the      #
!# host hydrodynamic model; done through the PUBLIC functions listed below.    #
!#                                                                             #
!#                                                                             #
!#   -----------------------------------------------------------------------   #
!#                                                                             #
!# Developed by :                                                              #
!#     AquaticEcoDynamics (AED) Group                                          #
!# (C) The University of Western Australia                                     #
!#                                                                             #
!# Copyright by the AED-team @ UWA under the GNU Public License - www.gnu.org  #
!#                                                                             #
!#   -----------------------------------------------------------------------   #
!#                                                                             #
!# Originally created Sept 2024                                                #
!# Follow updates @ https://github.com/AquaticEcoDynamics/libaed-fv            #
!#                                                                             #
!###############################################################################

#include "aed.h"

#define FV_AED_API_VERS "0.1.5"

#ifndef DEBUG
#define DEBUG      0
#endif

!###############################################################################
<<<<<<< HEAD
MODULE fv_api_aed
!-------------------------------------------------------------------------------
   USE aed_water
   USE aed_common
   USE fv_api_zones
=======
!MODULE fv_api_aed
MODULE fv_aed
!-------------------------------------------------------------------------------
   USE aed_util
   USE aed_water
   USE aed_common
!  USE fv_api_zones
   USE fv_zones
>>>>>>> 5575b76ae5b39c41209933b52fa78f78ab1df142
   USE ieee_arithmetic
   USE OMP_LIB

   USE aed_api


   IMPLICIT NONE

   PRIVATE

   PUBLIC init_aed_models,     &
          init_var_aed_models, &
          set_env_aed_models,  &
          set_env_particles,   &
          do_aed_models,       &
          clean_aed_models

   !#--------------------------------------------------------------------------#
   !# Module Types
   TYPE :: partgroup
      INTEGER(KIND=4) :: NP                                ! Number of Particles
      INTEGER(KIND=4) :: id_stat, id_i2, id_i3, id_layer   ! Particle ISTAT Index Values
      INTEGER(KIND=4) :: id_bed_layer, id_motility         ! Particle ISTAT Index Values
      INTEGER(KIND=4) :: id_uvw0, id_uvw, id_nu, id_wnd    ! Particle PROP Index Values
      INTEGER(KIND=4) :: id_wsel, id_watd, id_partd        ! Particle PROP Index Values
      INTEGER(KIND=4) :: id_age, id_state                  ! Particle TSTAT Index Values
      INTEGER(KIND=4) :: i_next                            ! next particle index
      INTEGER(KIND=4),POINTER,DIMENSION(:,:) :: istat      ! Particle Integer Status/Cell-index variables (4,NPart)
      REAL(KIND=8),POINTER,DIMENSION(:,:) :: tstat         ! Particle Time/Age Vector (2,Npart)
      REAL(KIND=8),POINTER,DIMENSION(:,:) :: xyz           ! particle position vector
      REAL(KIND=4),POINTER,DIMENSION(:,:) :: prop          ! Particle Property Vector (12,Npart)
      REAL(KIND=4),POINTER,DIMENSION(:,:) :: U             ! Particle Conserved Variable Vector (NU,NP)
   ENDTYPE partgroup
   TYPE :: partgroup_p
      INTEGER :: idx, grp
   ENDTYPE
   TYPE :: partgroup_cell
       INTEGER :: count, n
       TYPE(partgroup_p),ALLOCATABLE,DIMENSION(:) :: prt
   END TYPE partgroup_cell

   !#--------------------------------------------------------------------------#
   !# Module Data

   AED_REAL :: Kw, Ksed

   !# Main arrays storing/pointing to the state and diagnostic variables
   AED_REAL,DIMENSION(:,:),POINTER :: cc,    cc_diag
   AED_REAL,DIMENSION(:),  POINTER :: cc_hz, cc_diag_hz

   !# Maps of surface, bottom and wet/dry (active) cells
   INTEGER,DIMENSION(:),POINTER :: surf_map, benth_map
   LOGICAL,DIMENSION(:),POINTER :: active

   !# Maps to nearest cell with water (for riparian exchange)
   AED_REAL,DIMENSION(:),ALLOCATABLE,TARGET :: nearest_active
   AED_REAL,DIMENSION(:),ALLOCATABLE,TARGET :: nearest_depth
   INTEGER, DIMENSION(:),ALLOCATABLE        :: route_table

   !# Arrays for work, vertical movement (ws), and cross-boundary fluxes
   AED_REAL,DIMENSION(:,:),ALLOCATABLE :: flux
   AED_REAL,DIMENSION(:,:),ALLOCATABLE :: ws
   AED_REAL,DIMENSION(:)  ,ALLOCATABLE :: total
   AED_REAL,DIMENSION(:)  ,ALLOCATABLE :: Fsed_setl
   AED_REAL,DIMENSION(:)  ,ALLOCATABLE :: min_
   AED_REAL,DIMENSION(:)  ,ALLOCATABLE :: max_

   !# Arrays for environmental variables (used if they are not supplied externally)
   AED_REAL,DIMENSION(:),ALLOCATABLE,TARGET :: nir
   AED_REAL,DIMENSION(:),ALLOCATABLE,TARGET :: par
   AED_REAL,DIMENSION(:),ALLOCATABLE,TARGET :: uva
   AED_REAL,DIMENSION(:),ALLOCATABLE,TARGET :: uvb

   AED_REAL,DIMENSION(:),POINTER :: lpar
   AED_REAL,TARGET :: col_taub  ! a temp var for bottom stress (computed from ustar_bed)

   !# To support light - CAB these need to be passed in from tuflow, not sure how yet, so fudged
   AED_REAL,TARGET :: yearday
   AED_REAL :: part_day_per_step
   AED_REAL,DIMENSION(:),ALLOCATABLE,TARGET :: lon
   AED_REAL,DIMENSION(:),ALLOCATABLE,TARGET :: lat
   AED_REAL,TARGET :: longitude
   AED_REAL,TARGET :: latitude

   !# Name of files being used to load initial values for benthic
   !  or benthic_diag vars, and the horizontal routing table for riparian flows
   CHARACTER(len=128) :: init_values_file = ''
   CHARACTER(len=128) :: route_table_file = ''


   !# External variables
   AED_REAL,TARGET :: dt
<<<<<<< HEAD
   AED_REAL,DIMENSION(:,:),POINTER :: rad
   AED_REAL,DIMENSION(:),  POINTER :: temp
   AED_REAL,DIMENSION(:),  POINTER :: salt
   AED_REAL,DIMENSION(:),  POINTER :: rho
   AED_REAL,DIMENSION(:),  POINTER :: nuh
   AED_REAL,DIMENSION(:),  POINTER :: h
   AED_REAL,DIMENSION(:),  POINTER :: depth
   AED_REAL,DIMENSION(:),  POINTER :: dz
   AED_REAL,DIMENSION(:),  POINTER :: extc
   AED_REAL,DIMENSION(:),  POINTER :: tss
   AED_REAL,DIMENSION(:),  POINTER :: ss1
   AED_REAL,DIMENSION(:),  POINTER :: ss2
   AED_REAL,DIMENSION(:),  POINTER :: ss3
   AED_REAL,DIMENSION(:),  POINTER :: ss4
   AED_REAL,DIMENSION(:),  POINTER :: bio_drag
   AED_REAL,DIMENSION(:),  POINTER :: I_0
   AED_REAL,DIMENSION(:),  POINTER :: wnd
   AED_REAL,DIMENSION(:),  POINTER :: air_temp
   AED_REAL,DIMENSION(:),  POINTER :: air_pres
   AED_REAL,DIMENSION(:),  POINTER :: rain
   AED_REAL,DIMENSION(:),  POINTER :: humidity
   AED_REAL,DIMENSION(:),  POINTER :: longwave
   AED_REAL,DIMENSION(:),  POINTER :: area
   AED_REAL,DIMENSION(:),  POINTER :: bathy
   AED_REAL,DIMENSION(:),  POINTER :: shadefrac
   AED_REAL,DIMENSION(:),  POINTER :: rainloss
   AED_REAL,DIMENSION(:),  POINTER :: ustar_bed
   AED_REAL,DIMENSION(:),  POINTER :: wv_uorb
   AED_REAL,DIMENSION(:),  POINTER :: wv_t
   AED_REAL,DIMENSION(:),  POINTER :: vvel   !# vertical velocity
   AED_REAL,DIMENSION(:),  POINTER :: cvel   !# cell velocity

   AED_REAL,DIMENSION(:),POINTER :: layer_stress => null()
   AED_REAL,DIMENSION(:),POINTER :: sed_zones => null()
   AED_REAL,DIMENSION(:),POINTER :: pres => null()
=======
   AED_REAL,DIMENSION(:,:),POINTER :: rad       => null()
   AED_REAL,DIMENSION(:),  POINTER :: temp      => null()
   AED_REAL,DIMENSION(:),  POINTER :: salt      => null()
   AED_REAL,DIMENSION(:),  POINTER :: rho       => null()
   AED_REAL,DIMENSION(:),  POINTER :: nuh       => null()
   AED_REAL,DIMENSION(:),  POINTER :: h         => null()
   AED_REAL,DIMENSION(:),  POINTER :: depth     => null()
   AED_REAL,DIMENSION(:),  POINTER :: dz        => null()
   AED_REAL,DIMENSION(:),  POINTER :: extc      => null()
   AED_REAL,DIMENSION(:),  POINTER :: tss       => null()
   AED_REAL,DIMENSION(:),  POINTER :: ss1       => null()
   AED_REAL,DIMENSION(:),  POINTER :: ss2       => null()
   AED_REAL,DIMENSION(:),  POINTER :: ss3       => null()
   AED_REAL,DIMENSION(:),  POINTER :: ss4       => null()
   AED_REAL,DIMENSION(:),  POINTER :: bio_drag  => null()
   AED_REAL,DIMENSION(:),  POINTER :: I_0       => null()
   AED_REAL,DIMENSION(:),  POINTER :: wnd       => null()
   AED_REAL,DIMENSION(:),  POINTER :: air_temp  => null()
   AED_REAL,DIMENSION(:),  POINTER :: air_pres  => null()
   AED_REAL,DIMENSION(:),  POINTER :: rain      => null()
   AED_REAL,DIMENSION(:),  POINTER :: humidity  => null()
   AED_REAL,DIMENSION(:),  POINTER :: longwave  => null()
   AED_REAL,DIMENSION(:),  POINTER :: area      => null()
   AED_REAL,DIMENSION(:),  POINTER :: bathy     => null()
   AED_REAL,DIMENSION(:),  POINTER :: shadefrac => null()
   AED_REAL,DIMENSION(:),  POINTER :: rainloss  => null()
   AED_REAL,DIMENSION(:),  POINTER :: ustar_bed => null()
   AED_REAL,DIMENSION(:),  POINTER :: wv_uorb   => null()
   AED_REAL,DIMENSION(:),  POINTER :: wv_t      => null()
   AED_REAL,DIMENSION(:),  POINTER :: vvel      => null()    !# vertical velocity
   AED_REAL,DIMENSION(:),  POINTER :: cvel      => null()    !# cell velocity

   AED_REAL,DIMENSION(:),POINTER :: layer_stress => null()
   AED_REAL,DIMENSION(:),POINTER :: sed_zones    => null()
   AED_REAL,DIMENSION(:),POINTER :: pres         => null()
>>>>>>> 5575b76ae5b39c41209933b52fa78f78ab1df142

   !# maximum single precision real is 2**128 = 3.4e38
   AED_REAL :: glob_min = -1.0e38
   AED_REAL :: glob_max =  1.0e38
   LOGICAL  :: no_glob_lim = .FALSE.
<<<<<<< HEAD
=======
   AED_REAL :: min_water_depth =  0.0401
>>>>>>> 5575b76ae5b39c41209933b52fa78f78ab1df142

   LOGICAL  :: link_ext_par = .FALSE.
   LOGICAL  :: link_wave_stress = .FALSE.
   LOGICAL  :: link_solar_shade = .TRUE.
   LOGICAL  :: link_rain_loss = .FALSE.
   LOGICAL  :: link_water_clarity = .FALSE.
   LOGICAL  :: link_bottom_drag = .FALSE.
   LOGICAL  :: link_surface_drag = .FALSE.
   LOGICAL  :: link_water_density = .FALSE.

   AED_REAL :: wave_factor =  1.0
   LOGICAL  :: depress_clutch = .FALSE.
   LOGICAL  :: do_limiter = .FALSE.
   LOGICAL  :: do_particle_bgc = .FALSE.
   LOGICAL  :: do_zone_averaging = .FALSE.
   INTEGER  :: benthic_mode = 1
   LOGICAL  :: do_2d_atm_flux = .TRUE.

   AED_REAL,DIMENSION(:),ALLOCATABLE,TARGET :: colnums, mat

   !# Particle groups
   INTEGER :: num_groups
   TYPE(partgroup),DIMENSION(:),POINTER :: particle_groups
   TYPE(partgroup_cell),DIMENSION(:),ALLOCATABLE :: all_particles

   !# Misc variables/options
   LOGICAL  :: request_nearest = .FALSE.
   LOGICAL  :: have_nearest = .FALSE.
!  LOGICAL  :: reinited = .FALSE.
   INTEGER  :: ThisStep = 0
   INTEGER  :: n_cellids = 0

   TYPE(api_config_t) :: conf

   !# Integers storing number of variables being simulated
   INTEGER :: n_aed_vars, n_vars, n_vars_ben, n_vars_diag, n_vars_diag_sheet

CONTAINS
!===============================================================================


!###############################################################################
SUBROUTINE init_aed_models(namlst,dname,nwq_var,nben_var,ndiag_var,names,bennames,diagnames)
!-------------------------------------------------------------------------------
! This routine is called by the AED library host (TUFLOW-FV) to define numbers
! and names of variables. The host must then allocate the variables arrays
! after return from this routine.
!-------------------------------------------------------------------------------
!ARGUMENTS
   INTEGER,          INTENT(in)  :: namlst
   INTEGER,          INTENT(out) :: nwq_var,nben_var,ndiag_var
   CHARACTER(len=*), INTENT(in)  :: dname
   CHARACTER(len=30),ALLOCATABLE,INTENT(out) :: names(:)
   CHARACTER(len=30),ALLOCATABLE,INTENT(out) :: bennames(:)
   CHARACTER(len=30),ALLOCATABLE,INTENT(out) :: diagnames(:)
!
!LOCALS
   TYPE(aed_variable_t),POINTER :: tvar
   CHARACTER(len=128)           :: tname, line
   INTEGER                      :: status, n_sd, i, j, tv

!  %% NAMELIST   %%  /aed_bio/
   INTEGER  :: solution_method = 1

   CHARACTER(len=128) :: aed_nml_file = 'aed.nml'

   !# Switches for configuring model operation and active links with the host model
   AED_REAL :: base_par_extinction = 0.1
   LOGICAL  :: ext_tss_extinction = .FALSE.
   AED_REAL :: tss_par_extinction = 0.2

   !# maximum single precision real is 2**128 = 3.4e38
   AED_REAL :: glob_min = -1.0e38
   AED_REAL :: glob_max =  1.0e38
   LOGICAL  :: no_glob_lim = .FALSE.

<<<<<<< HEAD
   AED_REAL :: min_water_depth =  0.0401
=======
>>>>>>> 5575b76ae5b39c41209933b52fa78f78ab1df142
   INTEGER  :: n_equil_substep = 1

   LOGICAL  :: display_minmax = .FALSE.
   INTEGER  :: display_cellid(10) = -99

   AED_REAL :: nir_frac =  0.52   ! 0.51
   AED_REAL :: par_frac =  0.43   ! 0.45
   AED_REAL :: uva_frac =  0.048  ! 0.035
   AED_REAL :: uvb_frac =  0.002  ! 0.005

   AED_REAL :: longitude = 0.
   AED_REAL :: latlat = 0.

!  %% END NAMELIST   %%  /aed_bio/

   CHARACTER(len=64) :: models(64)

   NAMELIST /aed_models/ models

   NAMELIST /aed_bio/ solution_method, aed_nml_file, link_bottom_drag,         &
                      link_surface_drag, link_water_density,                   &
                      link_water_clarity,                                      &
                      link_ext_par, base_par_extinction,                       &
                      ext_tss_extinction, tss_par_extinction,                  &
                      do_particle_bgc, do_2d_atm_flux, do_zone_averaging,      &
                      link_solar_shade, link_rain_loss, init_values_file,      &
                      do_limiter, glob_min, glob_max, no_glob_lim,             &
                      route_table_file, n_equil_substep, min_water_depth,      &
                      link_wave_stress, wave_factor, display_minmax,           &
                      display_cellid, depress_clutch,                          &
                      nir_frac,par_frac,uva_frac,uvb_frac, longitude,latlat
!
!-------------------------------------------------------------------------------
!BEGIN
   print *, " "
   print *, "    using fv_aed version ", TRIM(FV_AED_API_VERS)

   ! Set default AED link options
   aed_nml_file        = 'aed.nml'
   solution_method     = 1
   link_bottom_drag    = .false.
   link_surface_drag   = .false.
   link_water_density  = .false.
   link_water_clarity  = .false.
   link_solar_shade    = .true.
   link_rain_loss      = .false.
   link_ext_par        = .false.
   base_par_extinction = 0.1
   ext_tss_extinction  = .false.
   tss_par_extinction  = 0.02
   do_2d_atm_flux      = .TRUE.
   do_limiter          = .false.
   no_glob_lim         = .false.
   do_particle_bgc     = .false.
   min_water_depth     = 0.0401
   link_wave_stress    = .false.
   display_minmax      = .false.
   display_cellid      = -99

   ! Process input file (aed.nml) to get run options
!  print *, "    initialise aed_core "
!  IF ( aed_init_core(dname, .true.) /= 0 ) STOP "Initialisation of aed_core failed"
!  CALL aed_print_version

   tname = TRIM(dname)//TRIM(aed_nml_file)
   print *,"    reading fv_aed config from ",TRIM(tname)
   OPEN(namlst,file=tname,action='read',status='old',iostat=status)
   IF ( status /= 0 ) CALL STOPIT("Cannot open file " // TRIM(tname))
   READ(namlst,nml=aed_bio,iostat=status)
   IF ( status /= 0 ) STOP "Cannot read namelist entry aed_bio"

   Kw = base_par_extinction
   Ksed = tss_par_extinction
   print *,'    link options configured between TFV & AED - '
   print *,'        link_ext_par       :  ',link_ext_par
   print *,'        link_water_clarity :  ',link_water_clarity
   print *,'        link_surface_drag  :  ',link_surface_drag,' (not implemented)'
   print *,'        link_bottom_drag   :  ',link_bottom_drag
   print *,'        link_wave_stress   :  ',link_wave_stress
   print *,'        link_solar_shade   :  ',link_solar_shade
   print *,'        link_rain_loss     :  ',link_rain_loss
   print *,'        link_particle_bgc  :  ',do_particle_bgc,' (under development)'
   print *,'        link_water_density :  ',link_water_density,' (not implemented)'

!# These config bits were from GLM - seems different set for tfv
!  conf%MaxLayers = MaxLayers

   conf%par_fraction =  0.450
   conf%nir_fraction =  0.510
   conf%uva_fraction =  0.035
   conf%uvb_fraction =  0.005

!  conf%mobility_off = mobility_off
!  conf%bioshade_feedback = bioshade_feedback
!  conf%repair_state = repair_state
   conf%link_rain_loss = link_rain_loss
   conf%link_solar_shade = link_solar_shade
   conf%link_bottom_drag = link_bottom_drag

!  conf%split_factor = split_factor
   conf%benthic_mode = benthic_mode

!  conf%rain_factor = rain_factor
!  conf%sw_factor = sw_factor
!  conf%friction = friction

   conf%Kw = Kw
!  conf%dt = dt

   CALL aed_config_model(conf)

   n_aed_vars = aed_init_model(tname, n_vars, n_vars_ben, n_vars_diag, n_vars_diag_sheet)
<<<<<<< HEAD
=======
   nwq_var = n_vars
   nben_var = n_vars_ben
   ndiag_var = n_vars_diag + n_vars_diag_sheet
>>>>>>> 5575b76ae5b39c41209933b52fa78f78ab1df142

   !# names = grab the names from info
   ALLOCATE(names(1:nwq_var),stat=status)
   IF (status /= 0) STOP 'allocate_memory(): ERROR allocating (names)'
   ALLOCATE(bennames(1:nben_var),stat=status)
   IF (status /= 0) STOP 'allocate_memory(): ERROR allocating (bennames)'
   IF ( .NOT. ALLOCATED(diagnames) ) ALLOCATE(diagnames(ndiag_var))
   IF (status /= 0) STOP 'allocate_memory(): ERROR allocating (diagnames)'

   ALLOCATE(min_(1:nwq_var+nben_var)) ; ALLOCATE(max_(1:nwq_var+nben_var))

   CLOSE(namlst)

   DO i=1,10
     IF ( display_cellid(i) /= -99 ) THEN
         n_cellids = n_cellids + 1
     ELSE
         EXIT
     ENDIF
   ENDDO
END SUBROUTINE init_aed_models
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
SUBROUTINE init_var_aed_models(nCells, cc_, cc_diag_, nwq, nwqben, sm, bm)
!-------------------------------------------------------------------------------
! Points the AED main variable arrays to those provided by the host model.
! At this point TuflowFV should have allocated the variable space.
!-------------------------------------------------------------------------------
!ARGUMENTS
   INTEGER,INTENT(in)                         :: nCells
   AED_REAL,POINTER,DIMENSION(:,:),INTENT(in) :: cc_, cc_diag_
   INTEGER,INTENT(inout)                      :: nwq, nwqben
   INTEGER,POINTER,DIMENSION(:),INTENT(in)    :: sm, bm
!
!LOCALS
   INTEGER :: rc, av, v, sv, d, sd
   TYPE(aed_variable_t),POINTER :: tv
   TYPE(api_data_t) :: aed_data
   TYPE(api_env_t) :: aed_env
!
!-------------------------------------------------------------------------------
!BEGIN
   nwq = n_vars
   nwqben = n_vars_ben

   print *,'    init_var_aed_models : nwq = ',nwq,' nwqben = ',nwqben

   cc => cc_
   cc_diag => cc_diag_
   surf_map => sm
   benth_map => bm

   ! Allocate state and diagnostic variable arrays
   IF ( .NOT. ASSOCIATED(cc) ) STOP ' ERROR : no association for (cc)'
   cc = 0.
   IF (.not. ASSOCIATED(cc_diag) ) STOP ' ERROR : no association for (cc_diag)'
   cc_diag = 0.

   aed_data%cc => cc
   aed_data%cc_hz => cc(1,:)
   aed_data%cc_diag => cc_diag
   aed_data%cc_diag_hz => cc_diag(1,:)

   CALL aed_set_model_data(aed_data)

   ! Allocate array with vertical movement rates (m/s, positive for upwards)
   ALLOCATE(ws(1:nCells,1:n_aed_vars),stat=rc)
   IF (rc /= 0) STOP 'allocate_memory(): ERROR allocating (ws)'
   ws = 0.

   !!# place holder for lagranigan particles
   !IF(do_particle_bgc) THEN
   !  pp => pp_
   !END IF

   ! Allocate array for photosynthetically active radiation (PAR).
   ! This will be calculated internally during each time step.
   ALLOCATE(par(1:nCells),stat=rc)
   IF (rc /= 0) STOP 'allocate_memory(): ERROR allocating (par)'
   par = 0.
   ALLOCATE(nir(1:nCells),stat=rc)
   IF (rc /= 0) STOP 'allocate_memory(): ERROR allocating (nir)'
   nir = 0.
   ALLOCATE(uva(1:nCells),stat=rc)
   IF (rc /= 0) STOP 'allocate_memory(): ERROR allocating (uva)'
   uva = 0.
   ALLOCATE(uvb(1:nCells),stat=rc)
   IF (rc /= 0) STOP 'allocate_memory(): ERROR allocating (uvb)'
   uvb = 0.

   !# Allocate array for sedimentation fluxes and initialize these to zero (no flux).
   ALLOCATE(Fsed_setl(1:nCells),stat=rc)
   IF (rc /= 0) STOP 'allocate_memory(): ERROR allocating (Fsed_setl)'
   Fsed_setl = 0.

   !# Now set initial values
   v = 0 ; sv = 0;
   DO av=1,n_aed_vars
      IF ( .NOT.  aed_get_var(av, tv) ) STOP "ERROR getting variable info"
      IF ( .NOT. ( tv%extern .OR. tv%diag) ) THEN  !# neither global nor diagnostic variable
         IF ( tv%sheet ) THEN
            sv = sv + 1
            cc(n_vars+sv, :) = tv%initial
         ELSE
            v = v + 1
            cc(v,:) = tv%initial
         ENDIF
      ENDIF
   ENDDO

   IF ( init_values_file /= '' ) CALL set_initial_from_file
   IF ( route_table_file /= '' ) CALL load_route_table(ubound(bm, 1))

   ALLOCATE(flux(n_vars+n_vars_ben, nCells),stat=rc) ; IF (rc /= 0) STOP 'allocate_memory(): ERROR allocating (flux)'

!
!-------------------------------------------------------------------------------
CONTAINS

   !############################################################################
   CHARACTER FUNCTION tolower(c)
   !----------------------------------------------------------------------------
   !ARGUMENTS
      CHARACTER, INTENT(in) :: c
   !LOCALS
      INTEGER :: ic
   !BEGIN
   !----------------------------------------------------------------------------
      ic = ichar(c)
      if (ic >= 65 .and. ic < 90) ic = (ic+32)
      tolower = char(ic)
   END FUNCTION tolower
   !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

   !############################################################################
   FUNCTION same_str_icase(a, b) RESULT(res)
   !----------------------------------------------------------------------------
   !ARGUMENTS
      CHARACTER(len=*), INTENT(in) :: a,b
   !LOCALS
      INTEGER :: len, i
      LOGICAL :: res
   !
   !BEGIN
   !----------------------------------------------------------------------------
      res = .FALSE.
      len = LEN_TRIM(a)
      IF ( len /= LEN_TRIM(b) ) RETURN
      DO i=1, len
         if (tolower(a(i:i)) /= tolower(b(i:i)) ) RETURN
      ENDDO
      res = .TRUE.
   END FUNCTION same_str_icase
   !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

   !############################################################################
   SUBROUTINE set_initial_from_file
   !----------------------------------------------------------------------------
   USE aed_csv_reader
   !
   !LOCALS
      INTEGER :: unit, nccols, ccol
      CHARACTER(len=32),POINTER,DIMENSION(:) :: csvnames
      TYPE(AED_SYMBOL),DIMENSION(:),ALLOCATABLE :: values
      INTEGER :: idx_col = 0, numv = 0, numd = 0, t
      INTEGER,DIMENSION(:),ALLOCATABLE :: vars, vmap
      INTEGER,DIMENSION(:),ALLOCATABLE :: dvar, dmap
      LOGICAL,DIMENSION(:),ALLOCATABLE :: vsheet, dsheet
      LOGICAL :: meh
   !
   !BEGIN
   !----------------------------------------------------------------------------
      unit = aed_csv_read_header(init_values_file, csvnames, nccols)
      IF (unit <= 0) RETURN !# No file found
      print *,'    benthic AED var initialisation from file: '
      print *,'        ', TRIM(init_values_file)

      DO ccol=1,nccols
         IF ( csvnames(ccol) == "ID" ) THEN
            idx_col = ccol
            EXIT
         ENDIF
      ENDDO

      ALLOCATE(vars(nccols))   ; ALLOCATE(vmap(nccols))
      ALLOCATE(dvar(nccols))   ; ALLOCATE(dmap(nccols))
      ALLOCATE(vsheet(nccols)) ; ALLOCATE(dsheet(nccols))
      ALLOCATE(values(nccols))
      vmap = 0 ; dmap = 0

      IF ( idx_col > 0 ) THEN
         v = 0 ; sv = 0; d = 0; sd = 0
         DO av=1,n_aed_vars
            IF ( .NOT. aed_get_var(av, tv) ) STOP "ERROR getting variable info"
            IF ( .NOT. ( tv%extern ) ) THEN  !#  dont do environment vars
               IF (tv%diag) THEN
                  d = d + 1
               ELSE
                  IF ( tv%sheet ) THEN
                     sv = sv + 1
                  ELSE
                     v = v + 1
                  ENDIF
               ENDIF
               DO ccol=1,nccols
                  IF ( same_str_icase(tv%name, csvnames(ccol)) ) THEN
                     IF (tv%diag) THEN
                        numd = numd + 1
                        dmap(numd) = ccol
                      ! IF ( same_str_icase(tv%name, "LND_phreatic") ) THEN
                      ! phreat_id = av ; phreat_col = ccol ; phreat_var = d ; ENDIF
                        dvar(numd) = d
                        dsheet(numd) = tv%sheet
                     ELSE
                        numv = numv + 1
                        vmap(numv) = ccol
                        IF ( tv%sheet ) THEN
                           vars(numv) = n_vars + sv
                        ELSE
                           vars(numv) = v
                        ENDIF
                        vsheet(numv) = tv%sheet
                     ENDIF
                  ENDIF
               ENDDO
            ENDIF
         ENDDO

         DO WHILE ( aed_csv_read_row(unit, values) )
            t = extract_integer(values(idx_col))
            DO v=1,numv
               IF ( vmap(v) == 0 ) CYCLE
               If ( vsheet(v) ) THEN
                  cc(vars(v), bm(t)) = extract_double(values(vmap(v)))
               ELSE
                  cc(vars(v), sm(t):bm(t)) = extract_double(values(vmap(v)))
               ENDIF
            ENDDO
            DO v=1,numd
               IF ( dmap(v) == 0 ) CYCLE
               ! IF (dmap(v) == phreat_col ) &
               ! print*, " XXX setting phreat_col ", phreat_var
               If ( vsheet(v) ) THEN
                  cc_diag(dvar(v), bm(t)) = extract_double(values(dmap(v)))
               ELSE
                  cc_diag(dvar(v), sm(t):bm(t)) = extract_double(values(dmap(v)))
               ENDIF
            ENDDO
         ENDDO
      ENDIF

      meh = aed_csv_close(unit) !# don't care if close fails

      IF (ASSOCIATED(csvnames)) DEALLOCATE(csvnames)
      IF (ALLOCATED(values))    DEALLOCATE(values)
      IF (ALLOCATED(vars))      DEALLOCATE(vars)
      IF (ALLOCATED(vmap))      DEALLOCATE(vmap)
      IF (ALLOCATED(dvar))      DEALLOCATE(dvar)
      IF (ALLOCATED(dmap))      DEALLOCATE(dmap)
   END SUBROUTINE set_initial_from_file
   !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

   !############################################################################
   SUBROUTINE load_route_table(nrows)
   !----------------------------------------------------------------------------
   USE aed_csv_reader
   !ARGUMENTS
      INTEGER,INTENT(in) :: nrows
   !
   !LOCALS
      INTEGER :: unit, nccols, ccol, crow
      CHARACTER(len=32),POINTER,DIMENSION(:) :: csvnames
      TYPE(AED_SYMBOL),DIMENSION(:),ALLOCATABLE :: values
      INTEGER :: idx_col = 0, t
      LOGICAL :: meh
   !
   !BEGIN
   !----------------------------------------------------------------------------
      unit = aed_csv_read_header(route_table_file, csvnames, nccols)
      IF (unit <= 0) RETURN !# No file found
      print *,'    riparian cell routing set from file: '
      print *,'        ', TRIM(route_table_file)

   !# The format of the file should be me, "lowest ajoining" - ie always 2 colums
   !# and always in the order - and we dont really care about the header, but
   !# being csv it should have it so we read but ignore it.
   !     DO ccol=1,nccols
   !        IF ( csvnames(ccol) == "ID" ) THEN
   !           idx_col = ccol
   !           EXIT
   !        ENDIF
   !     ENDDO
   !     IF (idx_col == 0) THEN
   !        print*,"Could not find column 'ID'"
   !        RETURN
   !     ENDIF
      idx_col = 1

      ALLOCATE(values(nccols))
      ALLOCATE(route_table(nrows))
      ALLOCATE(nearest_active(nrows))
      ALLOCATE(nearest_depth(nrows))
      route_table = 0

      crow = 0
      DO WHILE ( aed_csv_read_row(unit, values) )
         crow = crow + 1
         IF ( crow > nrows ) THEN
            print*, "        NOTE: routing table has more rows than expected - extras ignored"
         ENDIF
         t = extract_integer(values(idx_col))
         route_table(crow) = extract_integer(values(2))

         !MH PUT A CHECK HERE TO MAKE SURE NO CIRCULAR REFERENCE
      ENDDO

      IF ( crow < nrows ) &
      print*, "        NOTE: routing table has less rows than expected? ",crow,"/",nrows

      meh = aed_csv_close(unit)  !# don't care if close fails

      IF (ASSOCIATED(csvnames)) DEALLOCATE(csvnames)
      IF (ALLOCATED(values))    DEALLOCATE(values)
      have_nearest = .TRUE.
   END SUBROUTINE load_route_table
   !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

END SUBROUTINE init_var_aed_models
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
SUBROUTINE set_env_aed_models(dt_,              &
                            ! 3D env variables
                               temp_,            &
                               salt_,            &
                               rho_,             &
                               h_,               &
                               tss_,             &
                               rad_,             &
                               vvel_,            &
                               cvel_,            &
                            ! 3D feedback arrays
                               extcoeff_,        &
                            ! 2D env variables
                               area_,            &
                               I_0_,             &
                               longwave_,        &
                               wnd_,             &
                               rain_,            &
                               humidity_,        &
                               air_temp_,        &
                               ustar_bed_,       &
                               ustar_surf_,      &
                               wv_uorb_,         &
                               wv_t_,            &
                               z_,               &
                               bathy_,           &
                               mat_id_,          &
                               active_,          &
                            ! 2D feedback arrays
                               biodrag_,         &
                               solarshade_,      &
                               rainloss_,        &
                            ! some extra for light
                               time, lat_,       &
                            ! and more
                               air_pres_         &
                              )
!-------------------------------------------------------------------------------
! Provide environmental information from TuflowFV and set feedback arrays
!-------------------------------------------------------------------------------
!ARGUMENTS
   DOUBLETYPE, INTENT(in) :: dt_
   AED_REAL, INTENT(in), DIMENSION(:),   POINTER :: temp_, salt_, rho_, h_,    &
                                                    area_, tss_, extcoeff_, z_
   AED_REAL, INTENT(in), DIMENSION(:,:), POINTER :: rad_
   AED_REAL, INTENT(in), DIMENSION(:),   POINTER :: vvel_, cvel_
   AED_REAL, INTENT(in), DIMENSION(:),   POINTER :: I_0_, wnd_, ustar_bed_, ustar_surf_
   AED_REAL, INTENT(in), DIMENSION(:),   POINTER :: longwave_
   AED_REAL, INTENT(in), DIMENSION(:),   POINTER :: wv_uorb_, wv_t_
   AED_REAL, INTENT(in), DIMENSION(:),   POINTER :: rain_, bathy_
   AED_REAL, INTENT(in), DIMENSION(:),   POINTER :: air_temp_
   AED_REAL, INTENT(in), DIMENSION(:),   POINTER :: humidity_
   INTEGER,  INTENT(in), DIMENSION(:,:), POINTER :: mat_id_
   LOGICAL,  INTENT(in), DIMENSION(:),   POINTER :: active_
   AED_REAL, INTENT(in), DIMENSION(:),   POINTER :: biodrag_, solarshade_, rainloss_
   AED_REAL, INTENT(in)                          :: time
   AED_REAL, INTENT(in)                          :: lat_
   AED_REAL, INTENT(in), DIMENSION(:),   POINTER :: air_pres_
!
!LOCALS
   INTEGER :: i, j
   INTEGER :: nTypes, cType, nCols
   INTEGER, DIMENSION(:),ALLOCATABLE :: mat_t
   TYPE(api_env_t) :: aed_env
   TYPE(api_data_t) :: aed_data
!
!-------------------------------------------------------------------------------
!BEGIN
   print *,'    set_env_aed_models : linking to host environment vars '

   !# Provide pointers to arrays with environmental variables to AED.
   dt = dt_
   part_day_per_step = dt / 86400.
!  yearday = day_of_year(time) ! calc from time

   !# 2D (sheet) variables being pointed to
   area => area_
   I_0 => I_0_
   longwave => longwave_
   wnd => wnd_
   ustar_bed => ustar_bed_
   bathy => bathy_
   rain  => rain_
   shadefrac => solarshade_
   rainloss => rainloss_
   bio_drag => biodrag_
   air_temp => air_temp_
   IF ( ASSOCIATED(air_pres) ) THEN
     air_pres => air_pres_
   ELSE
     ALLOCATE(air_pres(SIZE(air_temp)))
     air_pres = 1013.25
   ENDIF
   humidity => humidity_
   IF(link_wave_stress)THEN
     wv_uorb => wv_uorb_
     wv_t => wv_t_
   END IF

   nCols = ubound(mat_id_,2)
   ALLOCATE(colnums(nCols))
   ALLOCATE(mat(nCols))
   DO I=1, nCols
      colnums(i) = i
      mat(i) = REAL(mat_id_(1,i))
   ENDDO

   !# 3D variables being pointed to
   h => h_               !# layer heights [1d array] needed for advection, diffusion
   depth => z_               !# depth [1d array], used to calculate local pressure
   extc => extcoeff_ !# biogeochemical light attenuation coefficients [1d array],
                         !# output of biogeochemistry, input for physics
   salt => salt_
   temp => temp_

   vvel => vvel_
   cvel => cvel_

   rho => rho_
   tss => tss_
   active => active_

   IF (link_ext_par) lpar => rad_(1,:)

   aed_env%yearday => yearday
   aed_env%timestep => dt !timestep

   aed_env%longitude => longitude
   aed_env%latitude  => latitude

   aed_env%temp          => temp
   aed_env%salt          => salt
   aed_env%rho           => rho
   aed_env%dz            => dz
   aed_env%height        => h
   aed_env%area          => area
   aed_env%depth         => depth
   aed_env%extc          => extc
   aed_env%tss           => tss
   aed_env%ss1           => ss1
   aed_env%ss2           => ss2
   aed_env%ss3           => ss3
   aed_env%ss4           => ss4
   aed_env%cvel          => cvel
   aed_env%vvel          => vvel
   aed_env%bio_drag      => bio_drag
!  aed_env%rad           => rad
   aed_env%I_0           => I_0
   aed_env%wnd           => wnd
   aed_env%air_temp      => air_temp
   aed_env%air_pres      => air_pres
   aed_env%rain          => rain
   aed_env%humidity      => humidity
   aed_env%longwave      => longwave
   aed_env%bathy         => bathy
   aed_env%rainloss      => rainloss
   aed_env%ustar_bed     => ustar_bed
   aed_env%wv_uorb       => wv_uorb
   aed_env%wv_t          => wv_t
   aed_env%layer_stress  => layer_stress
   aed_env%sed_zones     => sed_zones

   aed_env%par => par
   aed_env%nir => nir
   aed_env%uva => uva
   aed_env%uvb => uvb

   aed_env%pres => pres

   aed_env%sed_zones => sed_zones

   CALL aed_set_model_env(aed_env)

   aed_data%cc => cc
   aed_data%cc_hz => cc_hz
   aed_data%cc_diag => cc_diag
   aed_data%cc_diag_hz => cc_diag_hz

   CALL aed_set_model_data(aed_data)

<<<<<<< HEAD
   IF (n_zones .GT. 0) &
      CALL api_set_fv_zones(n_vars, n_vars_ben, n_vars_diag, n_vars_diag_sheet)

   CALL init_zones(ubound(mat_id_, 2), mat_id_, do_zone_averaging, n_vars, n_vars_ben, n_vars_diag)
=======
   CALL api_init_zones(ubound(mat_id_, 2), mat_id_, do_zone_averaging,         &
                             n_vars, n_vars_ben, n_vars_diag, n_vars_diag_sheet)
>>>>>>> 5575b76ae5b39c41209933b52fa78f78ab1df142

!print*,"allocating all_parts with ", ubound(temp,1), " cells"
   ALLOCATE(all_particles(ubound(temp,1)))

   ALLOCATE(lon(nCols)) ; lon = longitude
<<<<<<< HEAD
   ALLOCATE(lat(nCols)) ; lat = latlat !lat_ * 57.2958 ! convert to degrees
=======
   ALLOCATE(lat(nCols)) ; lat = lat_ * 57.2958 ! convert to degrees
>>>>>>> 5575b76ae5b39c41209933b52fa78f78ab1df142

END SUBROUTINE set_env_aed_models
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

<<<<<<< HEAD
=======
#if 0
>>>>>>> 5575b76ae5b39c41209933b52fa78f78ab1df142
! !###############################################################################
! SUBROUTINE CheckPhreatic
! !-------------------------------------------------------------------------------
! !ARGUMENTS
! !
! !LOCALS
!    AED_REAL :: flux_ben(n_vars+n_vars_ben), flux_atm(n_vars+n_vars_ben),       &
!                                             flux_rip(n_vars+n_vars_ben)
!    TYPE (aed_column_t) :: column(n_aed_vars)
!    INTEGER :: col, bot
! !
! !BEGIN
!    DO col=1, size(active)
!       bot = benth_map(col)
!       !# set column data structure from global arrays
!       CALL define_column(column, col, cc, cc_diag, flux, flux_atm, flux_ben, flux_rip)
!
!       print*," ^^^", column(phreat_id)%cell_sheet, cc_diag(phreat_var, bot)
!    ENDDO
! END SUBROUTINE CheckPhreatic


<<<<<<< HEAD
#if 0
=======
>>>>>>> 5575b76ae5b39c41209933b52fa78f78ab1df142
!###############################################################################
SUBROUTINE check_data
!-------------------------------------------------------------------------------
! Check that all variable dependencies have been met
!-------------------------------------------------------------------------------
!ARGUMENTS
!
!LOCALS
   INTEGER :: av, i, top, bot
   INTEGER :: v, d, sv, sd, ev, err_count
   TYPE(aed_variable_t),POINTER :: tvar
!-------------------------------------------------------------------------------
!BEGIN
   v = 0 ; d = 0; sv = 0; sd = 0 ; ev = 0
   err_count = 0

   DO av=1,n_aed_vars
      IF ( .NOT.  aed_get_var(av, tvar) ) STOP "ERROR getting variable info"

      IF ( tvar%extern ) THEN !# global variable
         ev = ev + 1
         SELECT CASE (tvar%name)
            CASE ( 'temperature' ) ; tvar%found = .true.
            CASE ( 'salinity' )    ; tvar%found = .true.
            CASE ( 'density' )     ; tvar%found = .true.
            CASE ( 'layer_ht' )    ; tvar%found = .true.
            CASE ( 'layer_area' )  ; tvar%found = .true.
            CASE ( 'rain' )        ; tvar%found = .true.
            CASE ( 'rainloss' )    ; tvar%found = .true.
            CASE ( 'material' )    ; tvar%found = .true.
            CASE ( 'bathy' )       ; tvar%found = .true.
            CASE ( 'extc_coef' )   ; tvar%found = .true.
            CASE ( 'tss' )         ; tvar%found = .true.
            CASE ( 'ss1' )         ; tvar%found = .true.
            CASE ( 'ss2' )         ; tvar%found = .true.
            CASE ( 'ss3' )         ; tvar%found = .true.
            CASE ( 'ss4' )         ; tvar%found = .true.
            CASE ( 'cell_vel' )    ; tvar%found = .true.
            CASE ( 'nir' )         ; tvar%found = .true.
            CASE ( 'par' )         ; tvar%found = .true.
            CASE ( 'uva' )         ; tvar%found = .true.
            CASE ( 'uvb' )         ; tvar%found = .true.
            CASE ( 'sed_zone' )    ; tvar%found = .true.
            CASE ( 'wind_speed' )  ; tvar%found = .true.
            CASE ( 'par_sf' )      ; tvar%found = .true.
            CASE ( 'taub' )        ; tvar%found = .true.
            CASE ( 'air_temp' )    ; tvar%found = .true.
            CASE ( 'air_pres' )    ; tvar%found = .true.
            CASE ( 'humidity' )    ; tvar%found = .true.
            CASE ( 'longwave' )    ; tvar%found = .true.
            CASE ( 'col_num' )     ; tvar%found = .true.
            CASE ( 'col_depth' )   ; tvar%found = .true.

            CASE ( 'nearest_active' ) ; tvar%found = have_nearest ; request_nearest = have_nearest
            CASE ( 'nearest_depth' )  ; tvar%found = have_nearest ; request_nearest = have_nearest

            CASE ( 'longitude' )   ; tvar%found = .true.
            CASE ( 'latitude' )    ; tvar%found = .true.
            CASE ( 'yearday' )     ; tvar%found = .true.
            CASE ( 'timestep' )    ; tvar%found = .true.
         !  CASE DEFAULT ; CALL STOPIT("ERROR: external variable "//trim(tvar%name)//" not found.")
         END SELECT
      ELSEIF ( tvar%diag ) THEN  !# Diagnostic variable
         IF ( tvar%sheet ) THEN
            sd = sd + 1
         ELSE
            d = d + 1
         ENDIF
      ELSE    !# state variable
         IF ( tvar%sheet ) THEN
            sv = sv + 1
         ELSE
            v = v + 1
         ENDIF
      ENDIF
      IF ( .NOT. tvar%found ) THEN
         print *, "ERROR: Undefined variable ", trim(tvar%name)
         err_count = err_count + 1
      ENDIF
   ENDDO

   if ( n_vars < v ) print *,"More vars than expected"
   if ( n_vars_ben < sv ) print *,"More sheet vars than expected"
   if ( n_vars_diag < sd + d ) print *,"More diag vars than expected"
   if ( n_vars_diag_sheet < sd ) print *,"More sheet diag vars than expected"

   IF ( err_count > 0 ) CALL STOPIT("*** ERRORs in configuration")
END SUBROUTINE check_data
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
SUBROUTINE define_column(column, col, cc, cc_diag, flux_pel, flux_atm, flux_ben, flux_rip)
!-------------------------------------------------------------------------------
! Set up the current column pointers
!-------------------------------------------------------------------------------
!ARGUMENTS
   TYPE (aed_column_t), INTENT(inout) :: column(:)
   INTEGER, INTENT(in) :: col
   AED_REAL, TARGET, INTENT(in) :: cc(:,:)       !# (n_vars, n_layers)
   AED_REAL, TARGET, INTENT(in) :: cc_diag(:,:)  !# (n_vars, n_layers)
   AED_REAL, TARGET, INTENT(inout) :: flux_pel(:,:) !# (n_vars, n_layers)
   AED_REAL, TARGET, INTENT(inout) :: flux_atm(:)   !# (n_vars)
   AED_REAL, TARGET, INTENT(inout) :: flux_ben(:)   !# (n_vars)
   AED_REAL, TARGET, INTENT(inout) :: flux_rip(:)   !# (n_vars)
!
!LOCALS
   INTEGER :: av, i, top, bot
   INTEGER :: v, d, sv, sd, ev
   TYPE(aed_variable_t),POINTER :: tvar
!-------------------------------------------------------------------------------
!BEGIN
   top = surf_map(col)
   bot = benth_map(col)

   v = 0 ; d = 0; sv = 0; sd = 0 ; ev = 0
   DO av=1,n_aed_vars

      IF ( .NOT.  aed_get_var(av, tvar) ) STOP "ERROR getting variable info"

      IF ( tvar%extern ) THEN !# global variable
         ev = ev + 1
         SELECT CASE (tvar%name)
            CASE ( 'temperature' ) ; column(av)%cell => temp(top:bot)
            CASE ( 'salinity' )    ; column(av)%cell => salt(top:bot)
            CASE ( 'density' )     ; column(av)%cell => rho(top:bot)
            CASE ( 'layer_ht' )    ; column(av)%cell => h(top:bot)
            CASE ( 'layer_area' )  ; column(av)%cell_sheet => area(col)
            CASE ( 'rain' )        ; column(av)%cell_sheet => rain(col)
            CASE ( 'rainloss' )    ; column(av)%cell_sheet => rainloss(col)
            CASE ( 'material' )    ; IF ( do_zone_averaging ) THEN
                                        column(av)%cell_sheet => zone(zm(col))
                                     ELSE
                                        column(av)%cell_sheet => mat(col)
                                     ENDIF
            CASE ( 'bathy' )       ; column(av)%cell_sheet => bathy(col)
            CASE ( 'extc_coef' )   ; column(av)%cell => extc(top:bot)
            CASE ( 'tss' )         ; column(av)%cell => tss(top:bot)
            CASE ( 'ss1' )         ; column(av)%cell => tss(top:bot)   !   For FV API 2.0 (To be connected to sed_conc)
            CASE ( 'ss2' )         ; column(av)%cell => tss(top:bot)   !   For FV API 2.0 (To be connected to sed_conc)
            CASE ( 'ss3' )         ; column(av)%cell => tss(top:bot)   !   For FV API 2.0 (To be connected to sed_conc)
            CASE ( 'ss4' )         ; column(av)%cell => tss(top:bot)   !   For FV API 2.0 (To be connected to sed_conc)
            CASE ( 'cell_vel' )    ; column(av)%cell => cvel(top:bot)
            CASE ( 'nir' )         ; column(av)%cell => nir(top:bot)
            CASE ( 'par' )         ; IF (link_ext_par) THEN
                                        column(av)%cell => lpar(top:bot)
                                     ELSE
                                        column(av)%cell => par(top:bot)
                                     ENDIF
            CASE ( 'uva' )         ; column(av)%cell => uva(top:bot)
            CASE ( 'uvb' )         ; column(av)%cell => uvb(top:bot)
            CASE ( 'sed_zone' )    ; column(av)%cell_sheet => zone(zm(col))
            CASE ( 'wind_speed' )  ; column(av)%cell_sheet => wnd(col)
            CASE ( 'par_sf' )      ; column(av)%cell_sheet => I_0(col)
            CASE ( 'taub' )        ; column(av)%cell_sheet => col_taub
            CASE ( 'air_temp' )    ; column(av)%cell_sheet => air_temp(col)
            CASE ( 'air_pres' )    ; column(av)%cell_sheet => air_pres(col)
            CASE ( 'humidity' )    ; column(av)%cell_sheet => humidity(col)
            CASE ( 'longwave' )    ; column(av)%cell_sheet => longwave(col)
            CASE ( 'col_num' )     ; column(av)%cell_sheet => colnums(col)
            CASE ( 'col_depth' )   ; column(av)%cell_sheet => depth(col)

            CASE ( 'nearest_active' ) ; column(av)%cell_sheet => nearest_active(col)
            CASE ( 'nearest_depth' )  ; column(av)%cell_sheet => nearest_depth(col)

            CASE ( 'longitude' )   ; column(av)%cell_sheet => lon(col)
            CASE ( 'latitude' )    ; column(av)%cell_sheet => lat(col)
            CASE ( 'yearday' )     ; column(av)%cell_sheet => yearday
            CASE ( 'timestep' )    ; column(av)%cell_sheet => dt

            CASE DEFAULT ; CALL STOPIT("ERROR: external variable "//trim(tvar%name)//" not found.")
         END SELECT
      ELSEIF ( tvar%diag ) THEN  !# Diagnostic variable
         d = d + 1
         IF ( tvar%sheet ) THEN
            column(av)%cell_sheet => cc_diag(d, bot)
         ELSE
            column(av)%cell => cc_diag(d,top:bot)
         ENDIF
      ELSE    !# state variable
         IF ( tvar%sheet ) THEN
            sv = sv + 1
            IF ( tvar%bot ) THEN
               column(av)%cell_sheet => cc(n_vars+sv, bot)
            ELSEIF ( tvar%top ) THEN
               column(av)%cell_sheet => cc(n_vars+sv, top)
            ENDIF
            column(av)%flux_ben => flux_ben(n_vars+sv)
            column(av)%flux_atm => flux_atm(n_vars+sv)
            column(av)%flux_rip => flux_rip(n_vars+sv)
         ELSE
            v = v + 1
            column(av)%cell => cc(v,top:bot)
            column(av)%flux_pel => flux_pel(v,top:bot)
            column(av)%flux_ben => flux_ben(v)
            column(av)%flux_atm => flux_atm(v)
            column(av)%flux_rip => flux_rip(v)
         ENDIF
      ENDIF
   ENDDO
END SUBROUTINE define_column
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
SUBROUTINE calculate_fluxes(column, count, z, flux_pel, flux_atm, flux_ben, flux_rip, h)
!-------------------------------------------------------------------------------
! Checks the current values of all state variables and repairs these
!-------------------------------------------------------------------------------
!ARGUMENTS
   TYPE (aed_column_t), INTENT(inout) :: column(:)
   INTEGER, INTENT(in) :: count, z
   AED_REAL, INTENT(inout) :: flux_pel(:,:) !# (n_vars, n_layers)
   AED_REAL, INTENT(inout) :: flux_atm(:)   !# (n_vars+n_ben)
   AED_REAL, INTENT(inout) :: flux_ben(:)   !# (n_vars+n_ben)
   AED_REAL, INTENT(inout) :: flux_rip(:)   !# (n_vars)
   AED_REAL, INTENT(inout) :: h(:)          !# (n_layers)
!
   INTEGER :: layer_map(count)
!
!LOCALS
   INTEGER :: i
!-------------------------------------------------------------------------------
!BEGIN
   flux_pel = zero_
   flux_atm = zero_
   flux_ben = zero_
   flux_rip = zero_

   !# Start with updating column diagnostics (currently only used for light)
   DO i=1, count
!     layer_map(i) = 1 + count-i
      layer_map(i) = i
   ENDDO
   CALL aed_calculate_column(column, layer_map)

   !# Calculate temporal derivatives due to air-water exchange.
   CALL aed_calculate_surface(column, 1)

   !# Distribute the fluxes into pelagic surface layer
   IF ( do_2d_atm_flux .OR. count > 1 ) &
      flux_pel(:,1) = flux_pel(:,1) + flux_atm(:)/h(1)

   IF ( do_zone_averaging ) THEN
      flux_pel(:,count) = flux_pel(:,count) + flux_pelz(:,z) !/h(count)

      !# Calculate temporal derivatives due to benthic exchange processes.
      CALL aed_calculate_benthic(column, count, .FALSE.)
   ELSE
      CALL aed_calculate_benthic(column, count)
   ENDIF

   !# Distribute bottom flux into pelagic over bottom box (i.e., divide by layer height).
   flux_pel(:,count) = flux_pel(:,count)/h(count)

   !# Add pelagic sink and source terms for all depth levels.
   DO i=1,count
      CALL aed_calculate(column, i)
   ENDDO

END SUBROUTINE calculate_fluxes
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
SUBROUTINE check_states(top, bot)
!-------------------------------------------------------------------------------
!USES
   USE IEEE_ARITHMETIC
!
!ARGUMENTS
!  TYPE (aed_column_t),INTENT(inout) :: column(:)
   INTEGER,INTENT(in) :: top, bot
!
!LOCALS
   TYPE(aed_variable_t),POINTER :: tv
   INTEGER i,v,d,lev
!
!-------------------------------------------------------------------------------
!BEGIN
   DO lev=top, bot
      !CALL aed_equilibrate(column, lev)
      v = 0; d = 0
      DO i=1,n_aed_vars
         IF ( aed_get_var(i, tv) ) THEN
            IF ( .NOT. (tv%diag .OR. tv%extern) ) THEN
               v = v + 1
               IF ( do_limiter ) THEN
                  IF ( .NOT. ieee_is_nan(min_(v)) ) THEN
                     IF ( cc(v, lev) < min_(v) ) cc(v, lev) = min_(v)
                  ELSE IF (.NOT. no_glob_lim) THEN
                     IF ( cc(v, lev) < glob_min ) THEN
                        print*, "Variable ", v, TRIM(tv%name), " below global min", cc(v, lev)
                        cc(v, lev) = MISVAL
                     ENDIF
                  ENDIF
                  IF ( .NOT. ieee_is_nan(max_(v)) ) THEN
                     IF ( cc(v, lev) > max_(v) ) cc(v, lev) = max_(v)
                  ELSE IF (.NOT. no_glob_lim) THEN
                     IF ( cc(v, lev) > glob_max ) THEN
                        print*, "Variable ", v, " TRIM(tv%name), above global max", cc(v, lev)
                        cc(v, lev) = MISVAL
                     ENDIF
                  ENDIF
               ENDIF
            ELSE IF ( tv%diag .AND. .NOT. no_glob_lim ) THEN
               d = d + 1
               IF ( cc_diag(d, lev) < glob_min .OR. cc_diag(d, lev) > glob_max ) THEN
                  print *, "Diagnostic ", d, TRIM(tv%name), " exceeded global bounds", cc_diag(d, lev)
                  cc_diag(d, lev) = MISVAL
               ENDIF
            ENDIF
         ENDIF
      ENDDO
   ENDDO
END SUBROUTINE check_states
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#endif


!###############################################################################
SUBROUTINE fill_nearest(nCols)
!-------------------------------------------------------------------------------
!ARGUMENTS
   INTEGER, INTENT(in) :: nCols
!
!LOCALS
   INTEGER  :: k, col, prev, next
!
!-------------------------------------------------------------------------------
!BEGIN
   IF ( ALLOCATED(route_table) ) THEN
      DO col=1, nCols
         IF (active(col) .AND. h(benth_map(col))>=min_water_depth) THEN
            nearest_active(col) = col
            nearest_depth(col) = h(benth_map(col)) + bathy(col)
         ELSE
            k = route_table(col)
            DO WHILE ( .NOT. active(k) .OR. h(benth_map(k))<min_water_depth)
               IF ( k == route_table(k) ) EXIT
               k = route_table(k)
            ENDDO
            nearest_active(col) = k
            nearest_depth(col) = h(benth_map(k)) + bathy(k)
            ! this needs fixing to sum over top:bot, as h is layer thicknesses, not references to datum
         ENDIF
      ENDDO
   ELSE
      nearest_active = 0.
   ENDIF
END SUBROUTINE fill_nearest
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
SUBROUTINE do_aed_models(nCells, nCols, time)
!-------------------------------------------------------------------------------
!ARGUMENTS
   INTEGER, INTENT(in) :: nCells, nCols
   AED_REAL,INTENT(in) :: time
!
!LOCALS
   TYPE(aed_variable_t),POINTER :: tv

   INTEGER :: i, j, col, lev, v, d
   AED_REAL,DIMENSION(:),POINTER :: tpar
   AED_REAL,PARAMETER :: r100 = 1.0e2
   INTEGER :: grp, prt, stat, idx3d
<<<<<<< HEAD
=======
   INTEGER :: wlev = 0.
>>>>>>> 5575b76ae5b39c41209933b52fa78f78ab1df142
!
!-------------------------------------------------------------------------------
!BEGIN
   !# for debugging, depress flag doesn't run the aed library - allows us to 
   !#  see how much time is used by libaed calculations by not doing them
   IF (depress_clutch) return

!$OMP BARRIER
!$OMP SINGLE
   print *,"    START do_aed_models"

   !#--------------------------------------------------------------------
   !# START-UP JOBS
   rainloss = zero_

   yearday = day_of_year(time) ! calc from time

   IF ( request_nearest ) CALL fill_nearest(nCols)

!  IF ( .NOT. reinited )  CALL re_initialize()

   ThisStep = ThisStep + 1

   ! if zone averaged module is running, create zone environment variables
   IF ( do_zone_averaging ) THEN
      IF (link_ext_par) THEN
         tpar => lpar
      ELSE
         tpar => par
      ENDIF
   ENDIF

   ! if bio-active particles are running, update particle data
   IF (do_particle_bgc) THEN
      DO i=1, size(all_particles)
         IF (ALLOCATED(all_particles(i)%prt)) DEALLOCATE(all_particles(i)%prt)
         all_particles(i)%count = 0
      ENDDO
      DO grp=1,num_groups
         stat = particle_groups(grp)%id_stat  ! should be 1
         idx3d = particle_groups(grp)%id_i3   ! should be 3
         DO prt=1,particle_groups(grp)%NP
            IF ( particle_groups(grp)%istat(stat, prt) >= 0 ) THEN
               i = particle_groups(grp)%istat(idx3d, prt)
               IF ( i >= 1 .AND. i <= size(all_particles) ) THEN
                  all_particles(i)%count = all_particles(i)%count + 1
!              ELSE
!                 print*,"idx out of range", i, size(all_particles)
!                 stop
               ENDIF
            ENDIF
         ENDDO
!     ENDDO
!     DO grp=1,num_groups
         DO prt=1,particle_groups(grp)%NP
            IF ( particle_groups(grp)%istat(stat, prt) < 0 ) CYCLE  !# ignore these

            i = particle_groups(grp)%istat(idx3d, prt)
            IF ( i >= 1 .AND. i <= size(all_particles) ) THEN
               IF (.NOT. ALLOCATED(all_particles(i)%prt)) THEN
                  ALLOCATE(all_particles(i)%prt(all_particles(i)%count))
                  all_particles(i)%n = 0
               ENDIF
               j = all_particles(i)%n + 1
               IF (j <= all_particles(i)%count ) THEN
                  all_particles(i)%prt(j)%grp = grp
                  all_particles(i)%prt(j)%idx = prt
                  all_particles(i)%n = j
!              ELSE
!                 print*,"Ooops, error in PTM", j, all_particles(i)%count
               ENDIF
!           ELSE
!              print*,"idx out of range", i, size(all_particles)
!              print*,"grp", grp, " prt ",prt
!              print*,"istat 1", particle_groups(grp)%istat(1,prt)
!              print*,"istat 2", particle_groups(grp)%istat(2,prt)
!              print*,"istat 3", particle_groups(grp)%istat(3,prt)
!              print*,"istat 4", particle_groups(grp)%istat(4,prt)
!              stop
            ENDIF
         ENDDO
      ENDDO
   ENDIF

!$OMP END SINGLE

<<<<<<< HEAD
=======
!  wlev = abs(top-bot)
>>>>>>> 5575b76ae5b39c41209933b52fa78f78ab1df142
   CALL aed_run_model(nCols, wlev, do_2d_atm_flux)

END SUBROUTINE do_aed_models
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
SUBROUTINE clean_aed_models
!-------------------------------------------------------------------------------
!ARGUMENTS
!
!LOCALS
!
!-------------------------------------------------------------------------------
!BEGIN
   ! Deallocate internal arrays
   IF (allocated(ws))             deallocate(ws)
   IF (allocated(total))          deallocate(total)
   IF (allocated(nir))            deallocate(nir)
   IF (allocated(par))            deallocate(par)
   IF (allocated(uva))            deallocate(uva)
   IF (allocated(uvb))            deallocate(uvb)
!  IF (allocated(pactive))        deallocate(pactive)
END SUBROUTINE clean_aed_models
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
SUBROUTINE Light(column, count, Io, extc, par_, h_)
!-------------------------------------------------------------------------------
!
! Calculate photosynthetically active radiation over entire column
! based on surface radiation, and background and biotic extinction.
!
!-------------------------------------------------------------------------------
!ARGUMENTS
   TYPE (aed_column_t), INTENT(inout) :: column(:)
   INTEGER,  INTENT(in)    :: count
   AED_REAL, INTENT(in)    :: Io
   AED_REAL, INTENT(inout) :: extc(:)
   AED_REAL, INTENT(inout) :: par_(:)
   AED_REAL, INTENT(inout) :: h_(:)
!
!LOCAL VARIABLES:
   INTEGER :: i
   AED_REAL :: zz, localext, localshade
!
!-------------------------------------------------------------------------------
!BEGIN
   zz = zero_
   localext = zero_

   CALL BioExtinction(column,count,extc)

   localext = extc(1)
   zz = 0.001 !0.5*h_(1)    !MH: assume top of layer
   par_(1) = 0.45 * Io * EXP( -(localext) * zz )

   IF (count <= 1) RETURN

   DO i = 2, count
      localext = extc(i)

      !zz = zz + 0.5*h_(i)
      zz = h_(i)
      par_(i) = par_(i-1) * EXP( -(localext) * zz )
   ENDDO
END SUBROUTINE Light
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
SUBROUTINE Settling(N,dt,h,wvel,Fsed,Y)
!-------------------------------------------------------------------------------
!
! Update settling of AED state variables in a given column
!
!-------------------------------------------------------------------------------
!ARGUMENTS
   INTEGER,INTENT(in)     :: N       !# number of vertical layers
   AED_REAL,INTENT(in)    :: dt      !# time step (s)
   AED_REAL,INTENT(in)    :: h(:)    !# layer thickness (m)
   AED_REAL,INTENT(in)    :: wvel(:) !# vertical advection speed
   AED_REAL,INTENT(inout) :: Fsed    !# value of sediment input due to settling
   AED_REAL,INTENT(inout) :: Y(:)
!
!CONSTANTS
   INTEGER,PARAMETER :: itmax=100
!
!LOCALS
   INTEGER  :: i,k,it
   AED_REAL :: step_dt
   AED_REAL :: Yc
   AED_REAL :: c,cmax
   AED_REAL :: cu(N+1)
!
!-------------------------------------------------------------------------------
!BEGIN
   Fsed = 0. !# initialize sediment settling fluxes with zero
   cu   = 0. !# initialize interface fluxes with zero
   cmax = 0. !# initialize maximum Courant number

   !# compute maximum Courant number
   !      calculated as number of layers that the particles will travel based
   !      on settling or buoyancy velocity.
   !      This number is then used to split the vertical movement
   !      calculations to limit movement across a single layer
   DO k=2,N
      !# sinking particles
      c=abs(wvel(k-1))*dt/(0.5*(h(k-1)+h(k)))
      IF (c > cmax) cmax=c
      !# rising particles
      c=abs(wvel(k))*dt/(0.5*(h(k-1)+h(k)))
      IF (c > cmax) cmax=c
   ENDDO

   it=min(itmax,int(cmax)+1)
   step_dt = dt / float(it);

   !# splitting loop
   DO i = 1,it
      !# vertical loop
      DO k=N,2,-1
         !# compute the slope ratio
         IF (wvel(k) > 0.) THEN !# Particle is rising
            Yc=Y(k)       !# central value
         ELSE !# negative speed Particle is sinking
            Yc=Y(k-1)     !# central value
         ENDIF

         !# compute the limited flux
         cu(k)=wvel(k) * Yc
      ENDDO

      !# do the upper boundary conditions
      cu(1) = zero_       !# limit flux into the domain from atmosphere

      !# do the lower boundary conditions
      IF (wvel(N) > 0.) THEN !# Particle is rising
         cu(N+1) = 0.  !flux from benthos is zero
      ELSE  !# Particle is settling
         cu(N+1) = wvel(N)*Y(N)
         Fsed = cu(N+1) * step_dt !# flux settled into the sediments per sub time step
      ENDIF
      !# do the vertical advection step including positive migration
      !# and settling of suspended matter.
      DO k=N,1,-1
          Y(k)=Y(k) - step_dt * ((cu(k) - cu(k+1)) / h(k))
      ENDDO
   ENDDO !# end of the iteration loop
   Fsed = Fsed / dt !# Average flux rate for full time step used in AED
END SUBROUTINE Settling
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
LOGICAL FUNCTION Riparian(column, actv, shade_frac, rain_loss)
!-------------------------------------------------------------------------------
!
! Do riparian functionality, including operations in dry and fringing cells &
! populate feedback arrays to the host model associated with riparian effects
!
!-------------------------------------------------------------------------------
!ARGUMENTS
   TYPE (aed_column_t), INTENT(inout) :: column(:)
   LOGICAL,  INTENT(in)    :: actv
   AED_REAL, INTENT(inout) :: shade_frac, rain_loss
!
!LOCAL VARIABLES:
   INTEGER :: i
   AED_REAL :: localshade
   AED_REAL :: localrainl
!
!-------------------------------------------------------------------------------
!BEGIN
   !# compute the methods relevant to either DRY or WET cells
   IF (.NOT. actv ) THEN
      CALL aed_calculate_dry(column, 1);
      CALL aed_calculate_riparian(column, 1, zero_);
   ELSE
      CALL aed_calculate_riparian(column, 1, one_);
   ENDIF

   !# update feedback arrays to host model, to reduce rain (or if -ve then add flow)
   CALL aed_rain_loss(column, 1, localrainl);
   IF (link_rain_loss) rain_loss = localrainl


   !# update feedback arrays to shade the water (ie reduce incoming light, Io)
   CALL aed_light_shading(column, 1, localshade)
   IF (link_solar_shade) shade_frac = localshade

   Riparian = actv
END FUNCTION Riparian
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
SUBROUTINE Update(column,count)
!-------------------------------------------------------------------------------
!
! Do non-kinetic (eg equilibrium) updates to state variables in AED modules
!
!-------------------------------------------------------------------------------
!ARGUMENTS
   TYPE (aed_column_t), INTENT(inout) :: column(:)
   INTEGER, INTENT(in) :: count
!
!LOCAL VARIABLES:
   INTEGER :: lev
!
!-------------------------------------------------------------------------------
!BEGIN
   DO lev=1,count
      CALL aed_equilibrate(column, lev)
   ENDDO
END SUBROUTINE Update
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
SUBROUTINE set_env_particles(ng,parts)
!-------------------------------------------------------------------------------
!ARGUMENTS
   INTEGER :: ng
   TYPE(partgroup),DIMENSION(:),TARGET,INTENT(in) :: parts
!
!-------------------------------------------------------------------------------
!BEGIN
   IF (.NOT. ASSOCIATED(particle_groups)) THEN
      particle_groups => parts
      num_groups = ng
   ENDIF
END SUBROUTINE set_env_particles
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
SUBROUTINE Particles(column, count, parts)
!-------------------------------------------------------------------------------
!
! Calculate biogeochemical transformations on particles !TO BE COMPLETED!
!
!-------------------------------------------------------------------------------
!ARGUMENTS
   TYPE (aed_column_t), INTENT(inout) :: column(:)
   TYPE(partgroup_cell), INTENT(inout) :: parts(:)
   INTEGER,  INTENT(in)    :: count
!
!LOCAL VARIABLES:
   INTEGER :: lev, grp, prt, n, pt, NU
   INTEGER :: ppid
   AED_REAL,DIMENSION(20) :: zz
   INTEGER :: stat, idxi3
!
!-------------------------------------------------------------------------------
!BEGIN
   IF (.NOT. ASSOCIATED(particle_groups) .OR. num_groups == 0) RETURN
   zz = zero_

   DO lev=1,count

      ppid = 0          ! new cell identifier, to allow cumulation of prts

      DO pt=1,parts(lev)%count

         grp = parts(lev)%prt(pt)%grp ; prt = parts(lev)%prt(pt)%idx
         stat = particle_groups(grp)%id_stat   ! should be 1
         idxi3 =  particle_groups(grp)%id_i3   ! should be 3

         IF ( particle_groups(grp)%istat(stat, prt) >= 0 ) THEN


            NU = ubound(particle_groups(grp)%U, 1)
            n = min(16, size(particle_groups(grp)%prop(:,prt)))

          ! zz(1:n) = particle_groups(grp)%prop(1:n,prt)
            zz(1)  = particle_groups(grp)%prop(particle_groups(grp)%id_uvw0, prt)
            zz(2)  = particle_groups(grp)%prop(particle_groups(grp)%id_uvw0+1, prt)
            zz(3)  = particle_groups(grp)%prop(particle_groups(grp)%id_uvw0+2, prt)
            zz(4)  = particle_groups(grp)%prop(particle_groups(grp)%id_uvw, prt)
            zz(5)  = particle_groups(grp)%prop(particle_groups(grp)%id_uvw+1, prt)
            zz(6)  = particle_groups(grp)%prop(particle_groups(grp)%id_uvw+2, prt)
            zz(7)  = particle_groups(grp)%prop(particle_groups(grp)%id_nu, prt)
            zz(8)  = particle_groups(grp)%prop(particle_groups(grp)%id_nu+1, prt)
            zz(9)  = particle_groups(grp)%prop(particle_groups(grp)%id_nu+2, prt)
            zz(10) = particle_groups(grp)%prop(particle_groups(grp)%id_nu+3, prt)
            zz(11) = particle_groups(grp)%prop(particle_groups(grp)%id_wsel, prt)
            zz(12) = particle_groups(grp)%prop(particle_groups(grp)%id_watd, prt)
            zz(13) = particle_groups(grp)%prop(particle_groups(grp)%id_partd, prt)
            zz(14) = particle_groups(grp)%prop(particle_groups(grp)%id_wnd, prt) !Vvel

            IF (NU > 0) zz(15) = particle_groups(grp)%U(1, prt)  !Mass
            IF (NU > 1) zz(16) = particle_groups(grp)%U(2, prt)

            zz(17:18) = particle_groups(grp)%tstat(1:2,prt)   !Birth and Age
            zz(19) = particle_groups(grp)%istat(stat, prt)    !Status

            CALL aed_particle_bgc(column,lev,ppid,zz)     !ppid getting incremeted in here

           !particle_groups(grp)%prop(1:n,prt) = zz(1:n)
            particle_groups(grp)%prop(particle_groups(grp)%id_uvw0, prt)   = zz(1)
            particle_groups(grp)%prop(particle_groups(grp)%id_uvw0+1, prt) = zz(2)
            particle_groups(grp)%prop(particle_groups(grp)%id_uvw0+2, prt) = zz(3)
            particle_groups(grp)%prop(particle_groups(grp)%id_uvw, prt)    = zz(4)
            particle_groups(grp)%prop(particle_groups(grp)%id_uvw+1, prt)  = zz(5)
            particle_groups(grp)%prop(particle_groups(grp)%id_uvw+2, prt)  = zz(6)
            particle_groups(grp)%prop(particle_groups(grp)%id_nu, prt)     = zz(7)
            particle_groups(grp)%prop(particle_groups(grp)%id_nu+1, prt)   = zz(8)
            particle_groups(grp)%prop(particle_groups(grp)%id_nu+2, prt)   = zz(9)
            particle_groups(grp)%prop(particle_groups(grp)%id_nu+3, prt)   = zz(10)
            particle_groups(grp)%prop(particle_groups(grp)%id_wsel, prt)   = zz(11)
            particle_groups(grp)%prop(particle_groups(grp)%id_watd, prt)   = zz(12)
            particle_groups(grp)%prop(particle_groups(grp)%id_partd, prt)  = zz(13)
            particle_groups(grp)%prop(particle_groups(grp)%id_wnd, prt)    = zz(14)

            IF (NU > 0) particle_groups(grp)%U(1, prt) = zz(15)
            IF (NU > 1) particle_groups(grp)%U(2, prt) = zz(16)
            particle_groups(grp)%istat(stat, prt) = zz(19)
         ENDIF
         particle_groups(grp)%tstat(2,prt) = particle_groups(grp)%tstat(2,prt) + dt
      ENDDO
   ENDDO
END SUBROUTINE Particles
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
SUBROUTINE BioExtinction(column,count,extc)
!-------------------------------------------------------------------------------
!
! Calculate the specific light attenuation additions due to AED modules
!
!-------------------------------------------------------------------------------
!ARGUMENTS
   TYPE (aed_column_t), INTENT(inout) :: column(:)
   INTEGER,  INTENT(in)    :: count
   AED_REAL, INTENT(inout) :: extc(:)
!
!LOCAL VARIABLES:
   INTEGER :: i
   AED_REAL :: localext
!
!-------------------------------------------------------------------------------
!BEGIN
   localext = zero_

   CALL aed_light_extinction(column, 1, localext)
   IF (link_water_clarity) THEN
     extc(1) = localext
   ELSE
     extc(1) = localext + Kw
   END IF

   IF (count <= 1) RETURN

   DO i = 2, count
      CALL aed_light_extinction(column, i, localext)
     IF (link_water_clarity) THEN
       extc(i) = localext
     ELSE
       extc(i) = localext + Kw
     END IF
   ENDDO
END SUBROUTINE BioExtinction
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
SUBROUTINE BioDrag(column,count,bdrag)
!-------------------------------------------------------------------------------
!
! Calculate the drag addition to be returned to the host model due to vegetation
!
!-------------------------------------------------------------------------------
!ARGUMENTS
   TYPE (aed_column_t), INTENT(inout) :: column(:)
   INTEGER,  INTENT(in)    :: count
   AED_REAL, INTENT(inout) :: bdrag
!
!LOCAL VARIABLES:
   INTEGER :: i
   AED_REAL :: localdrag
!
!-------------------------------------------------------------------------------
!BEGIN
   bdrag = zero_
   localdrag = zero_

   CALL aed_bio_drag(column, count, localdrag)

   IF (link_bottom_drag) bdrag = localdrag
END SUBROUTINE BioDrag
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
SUBROUTINE BioDensity(column,count,bio_density)
!-------------------------------------------------------------------------------
!
! Calculate the density addition to be returned to the host model due to WQ
!
!-------------------------------------------------------------------------------
!ARGUMENTS
   TYPE (aed_column_t), INTENT(inout) :: column(:)
   INTEGER,  INTENT(in)    :: count
   AED_REAL, INTENT(inout) :: bio_density(:)
!
!LOCAL VARIABLES:
   INTEGER :: i
   AED_REAL :: zz, localdensity
!
!-------------------------------------------------------------------------------
!BEGIN
   RETURN
END SUBROUTINE BioDensity
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
SUBROUTINE Stress(h,rho,taub,ustar,uorb,wvperiod)
!-------------------------------------------------------------------------------
!
! Calculate the density addition to be returned to the host model due to WQ
!
!-------------------------------------------------------------------------------
!ARGUMENTS
   AED_REAL, INTENT(in) :: h,rho,ustar
   AED_REAL, INTENT(in),OPTIONAL :: uorb,wvperiod
   AED_REAL, INTENT(inout) :: taub
!
!LOCAL VARIABLES:
   AED_REAL,PARAMETER :: pi = 4.0*ATAN(1.0)
   AED_REAL,PARAMETER :: nuw = 1.05e-6
   AED_REAL,PARAMETER :: ksw = 0.001
   AED_REAL,PARAMETER :: kappa = 0.41
   AED_REAL :: Aw,Rew,fwr,fws,fw,tauw
!
!-------------------------------------------------------------------------------
!BEGIN
   ! Current shear stress
   taub = rho*(ustar**2)

   IF( .NOT.PRESENT(uorb) .OR. .NOT.PRESENT(wvperiod) ) RETURN

   ! Shear stress due to wave-induced orbital velocity
   IF (h<0.05 .OR. uorb<0.001 .OR. wvperiod<0.01) THEN
   ELSE
      Aw = uorb*wvperiod/(2.*pi)
      Rew = uorb*Aw/nuw
      ! Smooth friction factor
      fws = 0.035*Rew**(-0.16)
      ! Turbulent friction factor
      fwr = EXP(5.21*(ksw/Aw)**0.194-5.98)
      fw = MAX(fws,fwr)
      ! Calculate wave stress (wave_factor allows for user scaling)
      tauw = (0.5*rho*fw*uorb**2)*wave_factor

      ! Total current + wave stress
      !-- a) mean bed shear
      taub = taub*( 1.+1.2*(tauw/(taub+tauw+1e-10))**3.2 )
      !-- b) RMS bed shear
      taub = SQRT( taub**2 + 0.5*tauw**2 )
   END IF
END SUBROUTINE Stress
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!###############################################################################
AED_REAL FUNCTION day_of_year(time)
!-------------------------------------------------------------------------------
!ARGUMENTS
  AED_REAL,INTENT(in) :: time
!
!LOCAL VARIABLES:
  integer :: j, jday
  integer :: y, m, d
  integer :: ya, c
  AED_REAL :: frac

!-------------------------------------------------------------------------------
  jday = INT4(time/86400.)
  frac = (time/86400) - jday
!print*, 'time is ', time, 'jday is ',jday, ' and frac is ', frac

  ! # calendar_date(jday,&y,&m,&d);

  j = jday - 1721119
  y = (4 * j - 1) / 146097

  j = 4 * j - 1 - 146097 * y
  d = j / 4
  j = (4 * d + 3) / 1461

  d = 4 * d + 3 - 1461 * j
  d = (d + 4) / 4
  m = (5 * d - 3) / 153

  d = 5 * d - 3 - 153 * m
  d = (d + 5) / 5
  y = 100 * y + j

  if (m < 10) then
      m = m + 3
  else
      m = m - 9;
      y = y + 1;
  endif

!print*, 'date : ', y, '/', m, '/', d

! return jday - julian_day(y,1,1);

  m = 1 ; d = 1

  if (m > 2) then
      m = m - 3
  else
      m = m + 9
      y = y - 1
  endif

  c = y / 100
  ya = y - 100 * c

  day_of_year = (146097 * c) / 4 + (1461 * ya) / 4 + (153 * m + 2) / 5 + d + 1721119

  day_of_year = jday - day_of_year + 1
!print*,'day of year ', day_of_year
  day_of_year = day_of_year + frac
!print*,'day of year with frac ', day_of_year

END FUNCTION day_of_year
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!===============================================================================
<<<<<<< HEAD
END MODULE fv_api_aed
=======
!END MODULE fv_api_aed
END MODULE fv_aed
>>>>>>> 5575b76ae5b39c41209933b52fa78f78ab1df142

!===============================================================================
!
!  * calc_zone areas
!  * do particles
!
!  * loop through columns :
!    + do mobility
!    + do settling
!    + do light
!
!  * if zones :
!      = copy to zones :
!        z_bottom_cell = z_bottom_cel + bottom_cell * (column area / zone_area)
!        z_bot_cell_diag = bot_cell_diag * (column area / zone_area)
!      = compute_zone_benthic
!      = copy_from zones :
!        - copy zone diag to columns bottom cell diags
!
!  * loop through columns :
!    + ch column
!      = do_stress
!      = some stuff
!      = calc_fluxes
!        - calc surface flux
!        - if zones :
!          # add zone pel-flux to column pel-flux
!          # calc benthic fluxes for those models not participating in zones
!        - else (not zones) :
!          # calc_benthic fluxes
!        - divide all pel fluxes by height
!        - do all pelagics
!      = Particles again ?
!      = loop top to bottom applying fluxes
!
!      = if zones :
!        - apply zone fluxes to cells
!      = else :
!        - apply benth fluxes
!
!      = do biodrag
!      = do bioextinction
!
!      = check states
!
!===============================================================================
